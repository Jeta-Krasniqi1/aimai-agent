"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDslColumns = toDslColumns;
exports.addColumnQuery = addColumnQuery;
exports.deleteColumnQuery = deleteColumnQuery;
exports.buildInsertQuery = buildInsertQuery;
exports.buildUpdateQuery = buildUpdateQuery;
exports.splitRowsByExistence = splitRowsByExistence;
exports.quoteIdentifier = quoteIdentifier;
exports.toTableName = toTableName;
exports.normalizeRows = normalizeRows;
exports.getPlaceholder = getPlaceholder;
const api_types_1 = require("@n8n/api-types");
const db_1 = require("@n8n/db");
const n8n_workflow_1 = require("n8n-workflow");
const not_found_error_1 = require("../../../errors/response-errors/not-found.error");
function toDslColumns(columns) {
    return columns.map((col) => {
        const name = new db_1.DslColumn(col.name.trim());
        switch (col.type) {
            case 'number':
                return name.int;
            case 'boolean':
                return name.bool;
            case 'string':
                return name.text;
            case 'date':
                return name.timestampTimezone();
            default:
                return name.text;
        }
    });
}
function dataStoreColumnTypeToSql(type, dbType) {
    switch (type) {
        case 'string':
            return 'TEXT';
        case 'number':
            return 'FLOAT';
        case 'boolean':
            return 'BOOLEAN';
        case 'date':
            if (dbType === 'postgres') {
                return 'TIMESTAMP';
            }
            return 'DATETIME';
        default:
            throw new not_found_error_1.NotFoundError(`Unsupported field type: ${type}`);
    }
}
function columnToWildcardAndType(column, dbType) {
    return `${quoteIdentifier(column.name, dbType)} ${dataStoreColumnTypeToSql(column.type, dbType)}`;
}
function isValidColumnName(name) {
    return api_types_1.DATA_STORE_COLUMN_REGEX.test(name);
}
function addColumnQuery(tableName, column, dbType) {
    if (!isValidColumnName(column.name)) {
        throw new n8n_workflow_1.UnexpectedError('bad column name');
    }
    const quotedTableName = quoteIdentifier(tableName, dbType);
    return `ALTER TABLE ${quotedTableName} ADD ${columnToWildcardAndType(column, dbType)}`;
}
function deleteColumnQuery(tableName, column, dbType) {
    const quotedTableName = quoteIdentifier(tableName, dbType);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quoteIdentifier(column, dbType)}`;
}
function buildInsertQuery(tableName, rows, columns, dbType = 'sqlite') {
    if (rows.length === 0 || Object.keys(rows[0]).length === 0) {
        return ['', []];
    }
    const keys = Object.keys(rows[0]);
    const quotedKeys = keys.map((key) => quoteIdentifier(key, dbType)).join(', ');
    const quotedTableName = quoteIdentifier(tableName, dbType);
    const columnTypeMap = buildColumnTypeMap(columns);
    const parameters = [];
    const valuePlaceholders = [];
    let placeholderIndex = 1;
    for (const row of rows) {
        const rowPlaceholders = keys.map((key) => {
            const value = normalizeValue(row[key], columnTypeMap[key], dbType);
            parameters.push(value);
            return getPlaceholder(placeholderIndex++, dbType);
        });
        valuePlaceholders.push(`(${rowPlaceholders.join(', ')})`);
    }
    const query = `INSERT INTO ${quotedTableName} (${quotedKeys}) VALUES ${valuePlaceholders.join(', ')}`;
    return [query, parameters];
}
function buildUpdateQuery(tableName, row, columns, matchFields, dbType = 'sqlite') {
    if (Object.keys(row).length === 0 || matchFields.length === 0) {
        return ['', []];
    }
    const updateKeys = Object.keys(row).filter((key) => !matchFields.includes(key));
    if (updateKeys.length === 0) {
        return ['', []];
    }
    const quotedTableName = quoteIdentifier(tableName, dbType);
    const columnTypeMap = buildColumnTypeMap(columns);
    const parameters = [];
    let placeholderIndex = 1;
    const setClause = updateKeys
        .map((key) => {
        const value = normalizeValue(row[key], columnTypeMap[key], dbType);
        parameters.push(value);
        return `${quoteIdentifier(key, dbType)} = ${getPlaceholder(placeholderIndex++, dbType)}`;
    })
        .join(', ');
    const whereClause = matchFields
        .map((key) => {
        const value = normalizeValue(row[key], columnTypeMap[key], dbType);
        parameters.push(value);
        return `${quoteIdentifier(key, dbType)} = ${getPlaceholder(placeholderIndex++, dbType)}`;
    })
        .join(' AND ');
    const query = `UPDATE ${quotedTableName} SET ${setClause} WHERE ${whereClause}`;
    return [query, parameters];
}
function splitRowsByExistence(existing, matchFields, rows) {
    const getMatchKey = (row) => JSON.stringify(Object.fromEntries(matchFields.map((field) => [field, row[field]])));
    const existingSet = new Set(existing.map((row) => getMatchKey(row)));
    const rowsToUpdate = [];
    const rowsToInsert = [];
    for (const row of rows) {
        const key = getMatchKey(row);
        if (existingSet.has(key)) {
            rowsToUpdate.push(row);
        }
        else {
            rowsToInsert.push(row);
        }
    }
    return { rowsToInsert, rowsToUpdate };
}
function quoteIdentifier(name, dbType) {
    switch (dbType) {
        case 'mysql':
        case 'mariadb':
            return `\`${name}\``;
        case 'postgres':
        case 'sqlite':
        default:
            return `"${name}"`;
    }
}
function toTableName(dataStoreId) {
    return `data_store_user_${dataStoreId}`;
}
function normalizeRows(rows, columns) {
    const typeMap = new Map(columns.map((col) => [col.name, col.type]));
    return rows.map((row) => {
        const normalized = { ...row };
        for (const [key, value] of Object.entries(row)) {
            const type = typeMap.get(key);
            if (type === 'boolean') {
                if (typeof value === 'boolean') {
                    normalized[key] = value;
                }
                else if (value === 1 || value === '1') {
                    normalized[key] = true;
                }
                else if (value === 0 || value === '0') {
                    normalized[key] = false;
                }
            }
            if (type === 'date' && value !== null && value !== undefined) {
                let dateObj = null;
                if (value instanceof Date) {
                    dateObj = value;
                }
                else if (typeof value === 'string' || typeof value === 'number') {
                    const parsed = new Date(value);
                    if (!isNaN(parsed.getTime())) {
                        dateObj = parsed;
                    }
                }
                normalized[key] = dateObj ? dateObj.toISOString() : value;
            }
        }
        return normalized;
    });
}
function normalizeValue(value, columnType, dbType) {
    if (['mysql', 'mariadb'].includes(dbType)) {
        if (columnType === 'date') {
            if (value instanceof Date ||
                (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/))) {
                return toMySQLDateTimeString(value);
            }
        }
    }
    return value;
}
function toMySQLDateTimeString(date, convertFromDate = true) {
    const dateString = convertFromDate
        ? date instanceof Date
            ? date.toISOString()
            : date
        : date;
    return dateString.replace('T', ' ').replace('Z', '');
}
function getPlaceholder(index, dbType) {
    return dbType.includes('postgres') ? `$${index}` : '?';
}
function buildColumnTypeMap(columns) {
    return Object.fromEntries(columns.map((col) => [col.name, col.type]));
}
//# sourceMappingURL=sql-utils.js.map