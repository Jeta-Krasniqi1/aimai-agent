"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreRowsRepository = void 0;
const db_1 = require("@n8n/db");
const di_1 = require("@n8n/di");
const typeorm_1 = require("@n8n/typeorm");
const sql_utils_1 = require("./utils/sql-utils");
function getConditionAndParams(filter, index, dbType) {
    const paramName = `filter_${index}`;
    const column = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(filter.columnName, dbType)}`;
    switch (filter.condition) {
        case 'eq':
            return [`${column} = :${paramName}`, { [paramName]: filter.value }];
        case 'neq':
            return [`${column} != :${paramName}`, { [paramName]: filter.value }];
    }
}
let DataStoreRowsRepository = class DataStoreRowsRepository {
    constructor(dataSource) {
        this.dataSource = dataSource;
    }
    async insertRows(tableName, rows, columns) {
        const dbType = this.dataSource.options.type;
        await this.dataSource.query.apply(this.dataSource, (0, sql_utils_1.buildInsertQuery)(tableName, rows, columns, dbType));
        return true;
    }
    async upsertRows(tableName, dto, columns) {
        const dbType = this.dataSource.options.type;
        const { rows, matchFields } = dto;
        if (rows.length === 0) {
            return false;
        }
        const { rowsToInsert, rowsToUpdate } = await this.fetchAndSplitRowsByExistence(tableName, matchFields, rows);
        if (rowsToInsert.length > 0) {
            await this.insertRows(tableName, rowsToInsert, columns);
        }
        if (rowsToUpdate.length > 0) {
            for (const row of rowsToUpdate) {
                const [query, parameters] = (0, sql_utils_1.buildUpdateQuery)(tableName, row, columns, matchFields, dbType);
                await this.dataSource.query(query, parameters);
            }
        }
        return true;
    }
    async deleteRows(tableName, ids) {
        if (ids.length === 0) {
            return true;
        }
        const dbType = this.dataSource.options.type;
        const quotedTableName = (0, sql_utils_1.quoteIdentifier)(tableName, dbType);
        const placeholders = ids.map((_, index) => (0, sql_utils_1.getPlaceholder)(index + 1, dbType)).join(', ');
        const query = `DELETE FROM ${quotedTableName} WHERE id IN (${placeholders})`;
        await this.dataSource.query(query, ids);
        return true;
    }
    async createTableWithColumns(tableName, columns, queryRunner) {
        const dslColumns = [new db_1.DslColumn('id').int.autoGenerate2.primary, ...(0, sql_utils_1.toDslColumns)(columns)];
        const createTable = new db_1.CreateTable(tableName, '', queryRunner);
        createTable.withColumns.apply(createTable, dslColumns);
        await createTable.execute(queryRunner);
    }
    async ensureTableAndAddColumn(dataStoreId, column, queryRunner, dbType) {
        const tableName = (0, sql_utils_1.toTableName)(dataStoreId);
        const tableExists = await queryRunner.hasTable(tableName);
        if (!tableExists) {
            await this.createTableWithColumns(tableName, [column], queryRunner);
        }
        else {
            await queryRunner.manager.query((0, sql_utils_1.addColumnQuery)(tableName, column, dbType));
        }
    }
    async dropColumnFromTable(dataStoreId, columnName, em, dbType) {
        await em.query((0, sql_utils_1.deleteColumnQuery)((0, sql_utils_1.toTableName)(dataStoreId), columnName, dbType));
    }
    async getManyAndCount(dataStoreId, dto) {
        const [countQuery, query] = this.getManyQuery(dataStoreId, dto);
        const data = await query.select('*').getRawMany();
        const countResult = await countQuery.select('COUNT(*) as count').getRawOne();
        const count = typeof countResult?.count === 'number' ? countResult.count : Number(countResult?.count) || 0;
        return { count: count ?? -1, data };
    }
    async getRowIds(dataStoreId, dto) {
        const [_, query] = this.getManyQuery(dataStoreId, dto);
        const result = await query.select('dataStore.id').getRawMany();
        return result;
    }
    getManyQuery(dataStoreTableName, dto) {
        const query = this.dataSource.createQueryBuilder();
        query.from(dataStoreTableName, 'dataStore');
        this.applyFilters(query, dto);
        const countQuery = query.clone().select('COUNT(*)');
        this.applySorting(query, dto);
        this.applyPagination(query, dto);
        return [countQuery, query];
    }
    applyFilters(query, dto) {
        const filters = dto.filter?.filters ?? [];
        const filterType = dto.filter?.type ?? 'and';
        const dbType = this.dataSource.options.type;
        const conditionsAndParams = filters.map((filter, i) => getConditionAndParams(filter, i, dbType));
        for (const [condition, params] of conditionsAndParams) {
            if (filterType === 'or') {
                query.orWhere(condition, params);
            }
            else {
                query.andWhere(condition, params);
            }
        }
    }
    applySorting(query, dto) {
        if (!dto.sortBy) {
            return;
        }
        const [field, order] = dto.sortBy;
        this.applySortingByField(query, field, order);
    }
    applySortingByField(query, field, direction) {
        const dbType = this.dataSource.options.type;
        const quotedField = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(field, dbType)}`;
        query.orderBy(quotedField, direction);
    }
    applyPagination(query, dto) {
        query.skip(dto.skip);
        query.take(dto.take);
    }
    async fetchAndSplitRowsByExistence(tableName, matchFields, rows) {
        const dbType = this.dataSource.options.type;
        const whereClauses = [];
        const params = [];
        for (const row of rows) {
            const clause = matchFields
                .map((field) => {
                params.push(row[field]);
                return `${(0, sql_utils_1.quoteIdentifier)(field, dbType)} = ${(0, sql_utils_1.getPlaceholder)(params.length, dbType)}`;
            })
                .join(' AND ');
            whereClauses.push(`(${clause})`);
        }
        const quotedFields = matchFields.map((field) => (0, sql_utils_1.quoteIdentifier)(field, dbType)).join(', ');
        const quotedTableName = (0, sql_utils_1.quoteIdentifier)(tableName, dbType);
        const query = `
        SELECT ${quotedFields}
        FROM ${quotedTableName}
        WHERE ${whereClauses.join(' OR ')}
    `;
        const existing = await this.dataSource.query(query, params);
        return (0, sql_utils_1.splitRowsByExistence)(existing, matchFields, rows);
    }
};
exports.DataStoreRowsRepository = DataStoreRowsRepository;
exports.DataStoreRowsRepository = DataStoreRowsRepository = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [typeorm_1.DataSource])
], DataStoreRowsRepository);
//# sourceMappingURL=data-store-rows.repository.js.map